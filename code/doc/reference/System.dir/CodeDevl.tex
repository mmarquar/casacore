\chapter{Code development}
\label{Code development}
\index{Code development}

Utilities specifically for programmers who are developing code in \aipspp\ 
\footnote{Last change:
$ $Id$ $}.

% ----------------------------------------------------------------------------

\section{Overview of code development}
\label{Overview of code development}
\index{overview -- code development}
\index{code development -- overview}

% ----------------------------------------------------------------------------

\newpage
\section{Coding conventions}
\label{Coding conventions}
\index{coding -- conventions}
\index{conventions -- conventions}

This section discusses some aspects of the \aipspp\ system which have a direct
effect on the way source code is written.

\subsection*{Include files}

It is essential in \aipspp\ that the

\begin{verbatim}
   #include <Header.h>
\end{verbatim}

\noindent
form of preprocessor \code{\#include} statement be used.  This form looks for
\file{Header.h} in the search path defined by \exe{-I} compiler options and
allows the \aipspp\ makefiles to control the include process.  The other form
admitted by the \textsc{c} preprocessor, namely

\begin{verbatim}
   #include "Header.h"
\end{verbatim}

\noindent
should never be used in \aipspp\ source code.  It causes the preprocessor to
look for the include file in the same directory as the source file, regardless
of the search path defined by \exe{-I} compiler options.  This may cause
problems where, for example, a programmer has checked out and is modifying a
\cplusplus\ class implementation file but doesn't have the relevant header
files checked out alongside.

Include files are specified as in the following example:

\begin{verbatim}
   #include <aips/Tables/Table.h>
\end{verbatim}

\noindent
This refers to the specific header file
\file{\$(AIPSCODE)/aips/implement/Tables/Table.h} by virtue of the symlink

\begin{verbatim}
   $(AIPSCODE)/include/aips -> $(AIPSCODE)/aips/implement
\end{verbatim}

\noindent
and the fact that \file{\$(AIPSCODE)/include} is added to the include path via
a \exe{-I} compiler option (see \sref{Code directories}).  Symlinks for each
package are created by the \code{symlinks} rule in the top-level makefile
(\sref{System generation makefile rules}), and they are created in programmer
workspaces by \exeref{mktree}.

Another caveat on include files is that they must have a \file{.h} file
suffix.  This is mandated by the need for \code{vpath} directives in the
makefiles, specifically for the dependency analysis used in programmer
compilations.

\subsection*{perl scripts}

\unixexe{perl} scripts must begin with a line of the form

\begin{verbatim}
   #!/usr/local/bin/perl4
\end{verbatim}

\noindent
or

\begin{verbatim}
   #!/usr/local/bin/perl5
\end{verbatim}

\noindent
When the scripts are installed the makefile will replace these strings with
the full pathname to the \unixexe{perl4} or \unixexe{perl5} executable encoded
in the \code{PERL4} and \code{PERL5} \file{makedefs} variables.

\subsection*{Documentation include files}

Files included by \TeX , \LaTeX\, and Texinfo source files may be deposited in
a subdirectory with the same basename as the source file but with a
\file{.dir} suffix.  For example, the source for this manual consists of
\file{System.latex} which simply defines the document style and a few commands
and environments and then includes a separate \file{.tex} file for each
chapter.  \file{System.latex} resides in \file{\$AIPSCODE/doc/reference} and
the chapters reside in \file{\$AIPSCODE/doc/reference/System.dir}.

The documentation makefile automatically adds any \file{.dir} subdirectory to
the \code{TEXINPUTS} environment variable which defines \TeX 's search path
for included files.  Note that, while \file{.dir} subdirectories can contain
any type of file, \TeX , \LaTeX\, and Texinfo may themselves impose
constraints, for example \LaTeX\ requires a \file{.tex} file suffix for
included files.

The \file{.dir} subdirectories should not contain a makefile.

\subsection*{HTML meta-markups}

The HTML comment

\noindent
\verb+   <!$+\verb+Date$>+

\noindent
may be used to automatically record timestamp information in the installed
\textsc{html} file.  The following fragment shows an example of its use,
typically near the end of the file:

\begin{verbatim}
   <P>Copyright &#169; 1996 Associated Universities Inc., Washington, D.C.</P>
   <ADDRESS>aips2adm@nrao.edu</ADDRESS>
\end{verbatim}

\noindent
\verb+   <!$+\verb+Date$>+

\begin{verbatim}
   </BODY>
   </HTML>
\end{verbatim}

\noindent
\rcs\ substitutes the current time (GMT) for the \verb+$\code{}Date$+ string
when the file is checked in (see \exeref{ai}) thereby transforming the
meta-markup to something resembling

\noindent
\verb+   <!$+\verb+Date: 1995/08/04 05:22:48 $>+

\noindent
The documentation makefile parses this into \textsc{html} and also adds the
time when the \file{.html} file was installed in the relevant subdirectory of
\file{\$AIPSDOCS} (see \sref{variables}).  Within an \textsc{html} browser the
result is as follows:

\begin{verbatim}
   Copyright (c) 1995 Associated Universities Inc., Washington, D.C.

   aips2adm@nrao.edu

   ---------------------------------------------------------------------------

   Modified:  1995/08/04 05:22:48 GMT
   Installed: 1995/08/06 19:32:08 GMT
\end{verbatim}

\noindent
It is permissable to insert additional text within the meta-markup as follows:

\noindent
\verb+   <!$+\verb+Date$ by mcalabre@atnf.csiro.au>+

\noindent
This would appear as:

\begin{verbatim}
   Copyright (c) 1995 Associated Universities Inc., Washington, D.C.

   aips2adm@nrao.edu

   ---------------------------------------------------------------------------

   Modified:  1995/08/04 05:22:48 GMT by mcalabre@atnf.csiro.au
   Installed: 1995/08/06 19:32:08 GMT
\end{verbatim}

\noindent
The \verb+<!$+\verb+Date$>+ meta-markup must appear as the first and only text
on a line (with no leading whitespace).  It should be the last item before the
\code{</BODY>} \textsc{html} markup.


% ----------------------------------------------------------------------------
 
\newpage
\section{\exe{ldmap}}
\label{ldmap}
\index{ldmap}
 
Determine dependencies between object modules from a namelist.

% ----------------------------------------------------------------------------

\newpage
\section{\file{Code development makefile usage}}
\label{Code development makefile usage}
\index{code development -- makefile usage}
\index{makefile usage -- code development}
\index{usage, makefile -- code development}
\index{compilation}
\index{makefiles}
\index{makefile - application}
\index{makefile - applications}
\index{makefile - checkout}
\index{makefile - class implemention}
\index{makefile - documentation}
\index{makefile - fortran directory}
\index{makefile - install directory}
\index{makefile - package}
\index{makefile - scripts directory}
\index{makefile - test directory}
\index{makefile - top-level}
\index{targets}
\index{code development -- makefiles}
\index{makefile.app}
\index{makefile.aps}
\index{makefile.chk}
\index{makefile.doc}
\index{makefile.ftn}
\index{makefile.imp}
\index{makefile.pkg}
\index{makefile.scr}
\index{makefile.tst}

\subsection*{The gmake command line - flags and variable definitions}


\subsection*{Programmer makedefs}


\subsection*{Creating a makefile}

   Include a generic makefile.\\
   XLIBLIST.\\
   HTML documents.

% ----------------------------------------------------------------------------

\newpage
\section{\file{Code development makefile rules}}
\label{Code development makefile rules}
\index{code development -- makefile rules}
\index{makefile rules -- code development}
\index{rules, makefile -- code development}
\index{compilation}
\index{makefiles}
\index{makefile - application}
\index{makefile - applications}
\index{makefile - checkout}
\index{makefile - class implemention}
\index{makefile - documentation}
\index{makefile - fortran directory}
\index{makefile - install directory}
\index{makefile - package}
\index{makefile - scripts directory}
\index{makefile - test directory}
\index{makefile - top-level}
\index{targets}
\index{code development -- makefiles}
\index{makefile.app}
\index{makefile.aps}
\index{makefile.chk}
\index{makefile.doc}
\index{makefile.ftn}
\index{makefile.imp}
\index{makefile.pkg}
\index{makefile.scr}
\index{makefile.tst}

\textsc{gnu} makefiles used to rebuild \aipspp\ 

\subsection*{Synopsis}

\begin{synopsis}
   \file{makefile}\\
   \file{makefile.\{app,aps,chk,doc,ftn,imp,pkg,scr,tst\}}
\end{synopsis}

\subsection*{Description}

\subsection*{AIPS++ code development targets}

The \aipspp\ makefile targets are listed below by category.  These lists
are not exhaustive, but do aim to cover everything of practical use.  In
particular, they omit targets which are intended for the internal use of the
makefiles.

A target is labelled as ``recursive'' if it causes \exeref{gmake} to be
invoked in all subdirectories.  It is ``general'' if it applies to all
makefiles; such targets are defined in \filref{makedefs}.  A target is
``specific'' if defined in a specific makefile.

Some targets such as \file{allsys} have a general meaning, the specific
behaviour of which differs for specific makefiles.  These are referred to as
``general/specific'' and where appropriate the details of a target's behaviour
are described for each of the generic makefiles, for the top-level makefile
(\file{top}), and the installation makefile (\file{ins}).

Targets which apply only if the \rcs\ source code repositories are present
are marked as ``\rcs''.


\textbf{Programmer-oriented targets:}

Rules for programmer-oriented targets look for source files first in the
programmer directory and if not found search the corresponding subdirectory of
\file{\$AIPSCODE} which is referred to below as \file{\$(CODEDIR)}.  This means
that programmers can compile code in their own workspace without having to
copy source files from \file{\$(CODEDIR)}, thereby minimizing the number of
files that need to be present in the programmer's workspace and reducing the
possibility that these may be ``stale''.

Certain variables are defined in \filref{makedefs} for the exclusive use of
programmer-oriented rules and may be redefined as necessary on the
\exeref{gmake} command line.  These are:

\begin{itemize}
\item
   \code{PGMRINCD}
   \\ Repository for include files produced by parser/generators such as
   \unixexe{lex} and \unixexe{bison}.

   The default \file{makedefs} sets this to \file{\$PGMRARCH} if that directory
   exists (but the site-specific \file{makedefs} may redefine it).

   Output is left in the current directory if \file{\$PGMRINCD} is blank

\item
   \code{PGMRAUXD}
   \\ Repository for dependency lists and timestamp files generated by the
   programmer dependency analysis.

   The default \file{makedefs} sets this to \file{\$PGMRARCH/aux} if that
   directory exists (but the site-specific \file{makedefs} may redefine it).

   Output is left in the current directory if \file{\$PGMRAUXD} is blank

\item
   \code{PGMRLIBD}
   \\ Programmer directory for class object modules and libraries.

   The default \file{makedefs} sets this to \file{\$PGMRARCH/lib} if that
   directory exists (but the site-specific \file{makedefs} may redefine it).

   Output is left in the current directory if \file{\$PGMRLIBD} is blank

\item
   \code{PGMRBIND}
   \\ Directory where programmer executables are deposited; programmers should
   add this directory to their \code{PATH}.

   The default \file{makedefs} sets this to \file{\$PGMRARCH/bin} if that
   directory exists (but the site-specific \file{makedefs} may redefine it).

   Output is left in the current directory if \file{\$PGMRBIND} is blank

\item
   \code{PGMRPTRD}
   \\ Directory serving as the programmer template repository.

   The default \file{makedefs} sets this to \file{\$PGMRARCH/ptrepository} as a
   suggestion and for the convenience of the site-specific \file{makedefs} in
   setting compiler options.  However, the site-specific \file{makedefs} may
   redefine it or simply ignore it, and \code{PGMRPTRD} is not used directly
   by any of the makefiles.

   Defaults to a compiler-specific directory if blank.

\item
   \code{EXTRA\_PGMRINCL}
   \\ Extra include directories to be {\em prepended} to the internally
   defined include path, \code{PGMRINCL}, which may also be redefined.

\item
   \code{EXTRA\_PGMRLIBS}
   \\ Extra object libraries to be {\em appended} to the internally
   defined library list, \code{PGMRLIBS}, which may also be redefined.

\item
   \code{OPT}
   \\ Optimization level to use for compilations.  The exact meaning of this
   is defined in the site-specific \file{makedefs} file.

\item
   \code{*FLAGS}
   \\ Options to be used for programmer compilations (\code{CPPFLAGS},
   \code{CFLAGS}, \code{C++FLAGS}, \code{FFLAGS}, and \code{LDFLAGS}).

\item
   \code{EXTRA\_*FLAGS}
   \\ Extra compiler flags to be appended to \code{*FLAGS} (\code{CPPFLAGS},
   \code{CFLAGS}, \code{C++FLAGS}, \code{FFLAGS}, and \code{LDFLAGS}).
\end{itemize}

\noindent
These variables may be printed with the \code{show\_prg} target.  The
\code{*FLAGS} variables are the subject of a convention for setting alternate
programmer compilation flags described in the section on \filref{makedefs}.

The programmer-oriented targets are as follows; note that where targets are
defined in terms of a \exeref{gmake} variable, for example \file{\$(SUBDIRS)},
it, and all other variables, may be printed via the \code{show\_all} target:

\begin{itemize}
\item
   \code{all} : (default programmer target, general/specific)
   \\ This is declared generally in \file{makedefs} as the default target if
   \exeref{gmake} has {\em not} been invoked from a subdirectory of
   \file{\$AIPSCODE}.  Its dependencies and commands are defined in the
   specific makefiles to compile all object modules, executables, etc. from
   files in the current directory.
   \begin{itemize}
   \item
      \file{app}: Compile this application and put the executable in
      \file{\$(PGMRBIND)}.
   \item
      \file{aps}: Compile all applications which have their main \file{.cc}
      file in the programmer's workspace and put the executables in
      \file{\$(PGMRBIND)}.
   \item
      \file{chk}: Does nothing.
   \item
      \file{doc}: Compile all \file{info} files and \textsc{PostScript}
      documents with sources in the current directory.
   \item
      \file{ftn}: Update all programmer object library modules which have
      sources in the current directory.
   \item
      \file{imp}: Update all programmer object library modules which have
      sources in the current directory.
   \item
      \file{ins}: Compile all utility programs with sources in the current
      directory.
   \item
      \file{pkg}: Does nothing.
   \item
      \file{src}: Does nothing.
   \item
      \file{top}: Create the \file{include} subdirectory and populate it with
      symbolic links to the \file{implement} directories of all installed
      packages (see \exeref{mktree}).
   \item
      \file{tst}: Compile all test programs with sources in the current
      directory and put the executables in \file{\$(PGMRBIND)}.
   \end{itemize}

\item
   \file{\$(SUBDIRS)} : (general)
   \\ \file{makedefs} sets the \code{SUBDIRS} variable to the names of all
   subdirectories which have a makefile, thus making them recognized targets.
   If the \rcs\ source code repositories exist then \file{\$(SUBDIRS)} lists
   the subdirectories of the corresponding \rcs\ directory.  This list is then
   made the target of a rule for creating the subdirectory and its \file{RCS}
   symlink (see \exeref{mktree}), and initiating a \exeref{gmake} within it.
   Note that this target has a system-oriented counterpart which behaves
   similarly.

\item
   \code{clean} : (general/specific)
   \\ This target causes intermediate files to be deleted.  It is defined
   generally in \file{makedefs} with a dependency which may be defined in the
   specific makefiles as the target of a rule to delete additional files.
   General files deleted are \file{*~}, \file{*\%}, \file{a.out},
   and \file{core}.  The specific makefiles may delete more:
   \begin{itemize}
   \item
      \file{app}: Deletes \file{*~}, \file{*\%}, and \file{\$(PCKGMOD).lock}
      from the \file{\$(PGMRAUXD)} directory, and deletes \file{*.i},
      \file{*.o}, \file{*.cdb}, \file{*.cyi}, \file{a.out}, and \file{core}
      from the \file{\$(PGMRBIND)} directory.
   \item
      \file{aps}: Deletes \file{*~}, \file{*\%}, and \file{\$(PACKAGE)=*.lock}
      from the \file{\$(PGMRAUXD)} directory, and deletes \file{*.i},
      \file{*.o}, \file{*.cdb}, \file{*.cyi}, \file{a.out}, and \file{core}
      from the \file{\$(PGMRBIND)} directory.
   \item
      \file{chk}: (none)
   \item
      \file{doc}: \file{*.aux}, \file{*.bbl}, \file{*.blg}, \file{*.cp},
      \file{*.cps}, \file{*.dvi}, \file{*.fi}, \file{*.fis}, \file{*.fn},
      \file{*.fns}, \file{*.ky}, \file{*.kys}, \file{*.lof}, \file{*.log},
      \file{*.pg}, \file{*.pgs}, \file{*.toc}, \file{*.tp}, \file{*.tps},
      \file{*.vr}, \file{*.vrs}, \file{*.info}, \file{*.info-*}
   \item
      \file{ftn}: Deletes \file{*.o} from the \file{\$(PGMRLIBD)} directory.
   \item
      \file{imp}: Deletes \file{*.i}, \file{*.o}, \file{*.cdb},
      \file{*.cyi}, \file{a.out}, and \file{core} from the \file{\$(PGMRLIBD)}
      directory, and deletes \file{*~}, \file{*\%}, \file{*.lcc}, and
      \file{*.ycc} from the \file{\$(PGMRINCD)} directory.
   \item
      \file{ins}: \file{*.i}, \file{*.o}
   \item
      \file{pkg}: (none)
   \item
      \file{src}: (none)
   \item
      \file{top}: (none)
   \item
      \file{tst}: Deletes \file{*.i}, \file{*.o}, \file{*.cdb}, \file{*.cyi},
      \file{a.out}, and \file{core} from the \file{\$(PGMRBIND)} directory.
   \end{itemize}

\item
   \code{cleaner} : (general/specific)
   \\ This target is defined generally in \file{makedefs} with a dependency
   which may be defined in the specific makefiles as the target of a rule to
   delete additional files.  Generally this target invokes the \code{clean}
   target and then deletes source files in the current directory which have
   been checked out without a lock.  It determines these as any file in the
   current directory without write permission and with a corresponding
   \rcs\ version file.  The specific makefiles may go further:
   \begin{itemize}
   \item
      \file{app}: The executable for the application and its dependency lists
      and timestamp files.
   \item
      \file{aps}: The executables for any applications with source code in
      system or programmer application subdirectories, and the dependency
      lists and timestamp files for all applications in this package.
   \item
      \file{chk}: (none)
   \item
      \file{doc}: (none)
   \item
      \file{ftn}: The programmer's private \textsc{fortran} library for the
      package.
   \item
      \file{imp}: The programmer's private \code{C++} library for the
      package, and the dependency lists and timestamp files for the
      package/module.
   \item
      \file{ins}: The executables for any utility programs with source code in
      the current directory or \file{\$(CODEDIR)}.
   \item
      \file{pkg}: (none)
   \item
      \file{scr}: (none)
   \item
      \file{top}: (none)
   \item
      \file{tst}: The executables for any test programs with source code in
      the current directory or \file{\$(CODEDIR)}, and the dependency lists
      and timestamp files for the package test files.
   \end{itemize}

\item
   \code{cleanest} : (general/specific)
   \\ This target is defined generally in \file{makedefs} with a dependency
   which may be defined in the specific makefiles as the target of a rule to
   delete additional files.  Generally this target just invokes the
   \code{cleaner} target.  The specific makefiles may go further:
   \begin{itemize}
   \item
      \file{app}: (none)
   \item
      \file{aps}: (none)
   \item
      \file{chk}: (none)
   \item
      \file{doc}: (none)
   \item
      \file{ftn}: (none)
   \item
      \file{imp}: All of the programmer's object libraries and dependency
      lists and timestamp files, and the template repository.
   \item
      \file{ins}: (none)
   \item
      \file{pkg}: (none)
   \item
      \file{scr}: (none)
   \item
      \file{top}: (none)
   \item
      \file{tst}: (none)
   \end{itemize}

   \noindent
   Note that since this target has the potential to delete much more than
   was possibly desired by the programmer it is advisable to do a dry run
   using

\begin{verbatim}
   gmake -n cleanest
\end{verbatim}

   \noindent
   before using it.

\item
   \file{\%.lcc} : (specific, pattern rule)
   \\ Preprocess a \file{.l} file using \code{\$(LEX)} and leave the resulting
   \file{.lcc} file in \file{\$(PGMRINCD)}.
   \begin{itemize}
   \item
      \file{imp}: Preprocess the \file{.l} file associated (probably) with a
      class implementation.
   \end{itemize}

\item
   \file{\%.ycc} : (specific, pattern rule)
   \\ Preprocess a \file{.y} file using \code{\$(BISON)} and leave the
   resulting \file{.ycc} file in \file{\$(PGMRINCD)}.
   \begin{itemize}
   \item
      \file{imp}: Preprocess the \file{.y} file associated (probably) with a
      class implementation.
   \end{itemize}

\item
   \file{\%.d} : (specific, pattern rule)
   \\ List the dependencies of a source file.  A side effect of this is to
   update the dependency list for the particular source file if necessary.
   The programmer dependency list is not necessarily the same as that which
   applies for a system compilation of the same source file if the programmer
   has private versions of the source file or any of the relevant header
   files.
   \begin{itemize}
   \item
      \file{app}: List the dependencies of an application.
   \item
      \file{imp}: List the dependencies of a class implementation file.
   \item
      \file{tst}: List the dependencies of test program.
   \end{itemize}

\item
   \file{\%.i} : (specific, pattern rule)
   \\ Apply the \code{C} preprocessor \code{\$(CPP)} to a source file in the
   current directory or \file{\$(CODEDIR)} and put the resulting \file{.i}
   file in \file{\$(PGMRLIBD)}.
   \begin{itemize}
   \item
      \file{app}: Preprocess the \file{.cc} file for an application.  The
      include path will be augmented with current directory (i.e. \code{-I.})
      and of the corresponding system directory, \file{\$(CODEDIR)}, in that
      order.
   \item
      \file{imp}: Preprocess the \file{.cc} file for a class implementation.
   \item
      \file{tst}: Preprocess the \file{.cc} file for a test program.
   \end{itemize}

\item
   \file{\%.o} : (specific, pattern rule)
   \\ Produce an object module from the corresponding source file in the
   current directory or \file{\$(CODEDIR)} and put it in \file{\$(PGMRLIBD)}.
   Debug compilations are done by default, but optimized compilations can be
   selected via the \code{OPT} variable or alternate programmer compilation
   flags (see \filref{makedefs}).
   \begin{itemize}
   \item
      \file{app}: Compile the \file{.cc} file for an application into an
      object module and put it in \file{\$(PGMRLIBD)}.  The include path will
      be augmented with current directory (i.e. \code{-I.}) and of the
      corresponding system directory, \file{\$(CODEDIR)}, in that order.
   \item
      \file{ftn}: Compile the \file{.f} file for a \textsc{fortran} subroutine into
      an object module and put it in \file{\$(PGMRLIBD)}.
   \item
      \file{imp}: Compile the \file{.cc} file for a \code{C++} class
      implementation into an object module and put it in \file{\$(PGMRLIBD)}.
   \item
      \file{ins}: Compile the \file{.c} file for a utility program into an
      object module and leave it in the current directory.
   \item
      \file{tst}: Compile the \file{.cc} file for a test program into an
      object module and put it in \file{\$(PGMRLIBD)}.
   \end{itemize}

\item
   \code{mylib(\%.o)} : (specific, pattern rule)
   \\ Compile an object module using the \file{\%.o} pattern rule and insert it
   into a private library in \file{\$(PGMRLIBD)}, then apply \code{\$(RANLIB)}
   to the library.
   \begin{itemize}
   \item
      \file{ftn}: Compile the \file{.f} file for a \textsc{fortran} subroutine
      and insert it into a private \textsc{fortran} library.
   \item
      \file{imp}: Compile the \file{.cc} file for a \code{C++} class
      implementation and insert it into a private \code{C++} library.
   \end{itemize}

\item
   \code{\%} : (specific, catch-all pattern rule or static pattern rule)
   \\ Compile an object module or executable.
   \begin{itemize}
   \item
      \file{app}: Catch-all pattern rule to compile an executable.  Debug
      compilations are done by default, but optimized compilations can be
      selected via the \code{OPT} variable or alternate programmer compilation
      flags (see \filref{makedefs}).

      The include path will be augmented with current directory (i.e.
      \code{-I.}) and of the corresponding system directory,
      \file{\$(CODEDIR)}, in that order.  This allows an application to
      maintain a set of include files specific to it.

      The executable will be linked against the library list specified by
      \code{\$(PGMRLIBS)} in which private programmer libraries are listed
      before system libraries (see above).

      The executable will be left in \file{\$(PGMRBIND)}.
   \item
      \file{ftn}:  Catch-all pattern rule to compile a \textsc{fortran} subroutine
      if the corresponding library module is out-of-date.  The resultant object
      module is left in the \file{\$(PGMRLIBD)} directory and is not inserted
      into the library.  Refer to the entry for the \file{imp} makefile.
   \item
      \file{imp}:  Catch-all pattern rule to compile a class implementation if
      the corresponding library module is out-of-date.  The resultant object
      module is left in the \file{\$(PGMRLIBD)} directory and is not inserted
      into the library.

      This rule may be used in conjunction with \code{update\_mylib} to update
      several library modules in one invokation of \exeref{gmake} without
      updating the library for each one.  For example,

\begin{verbatim}
   gmake Bloggs Boggle update_mylib
\end{verbatim}

      \noindent
      Note that this is not the same as

\begin{verbatim}
   gmake Bloggs.o Boggle.o update_mylib
\end{verbatim}

      \noindent
      Which may cause the object modules to be compiled even if the library
      modules are up-to-date with respect to their sources.
   \item
      \file{ins}: Static pattern rule on \file{\$(ALLEXES)} to compile a
      utility program leaving the executable in the current directory.
   \item
      \file{app}: Catch-all pattern rule to compile an executable.  Debug
      compilations are done by default, but optimized compilations can be
      selected via the \code{OPT} variable or alternate programmer compilation
      flags (see \filref{makedefs}).

      The executable will be linked against the library list specified by
      \code{\$(PGMRLIBS)} in which private programmer libraries are listed
      before system libraries (see above).

      The executable will be left in \file{\$(PGMRBIND)}.
   \end{itemize}

\item
   \code{depend} : (specific)
   \\ Determine dependencies for all sources in the current directory.
   \begin{itemize}
   \item
      \file{app}: Determine dependencies for the application.
   \item
      \file{aps}: Determine dependencies for all applications which have their
      main \file{.cc} file in the programmer's workspace, \file{\$(PGMREXES)}.
   \item
      \file{imp}: Determine dependencies for all class implementations with
      sources in the current directory, \file{\$(PGMRIMPS)}.
   \item
      \file{tst}: Determine dependencies for all test programs with sources in
      the current directory, \file{\$(PGMREXES)}.
   \end{itemize}

\item
   \code{dependencies} : (specific, recursive)
   \\ Determine dependencies for all sources in the current directory and in
   \file{\$(CODEDIR)}.
   \begin{itemize}
   \item
      \file{aps}: Determine programmer dependencies for all programmer and
      system applications in this package, \file{\$(ALLEXES)}.  This comprises
      all applications which have their main \file{.cc} file in the
      programmer's workspace, \file{\$(PGMREXES)}, and in the corresponding
      system directory, \file{\$(AIPSEXES)}.
   \item
      \file{imp}: Determine dependencies for all class implementations in the
      current directory and in \file{\$(CODEDIR)} and likewise for all
      subdirectories.
   \item
      \file{tst}: Determine dependencies for all test programs in the current
      directory and in \file{\$(CODEDIR)}.
   \end{itemize}

\item
   \code{mylib} : (specific)
   \\ Compile all sources in the current directory and in \file{\$(CODEDIR)} to
   build a complete private object library.
   \begin{itemize}
   \item
      \file{ftn}: Build a private \textsc{fortran} library.
   \item
      \file{imp}: Build a private \code{C++} library.
   \end{itemize}

\item
   \code{mylibs} : (specific)
   \\ Invoke the \code{mylib} rule in the current directory and all
   subdirectories.
   \begin{itemize}
   \item
      \file{imp}: Build all private \code{C++} libraries.
   \end{itemize}

\item
   \code{update\_mylib} : (specific)
   \\ Insert all object modules into a private library and then apply
   \code{\$(RANLIB)} to it.  The object modules and library reside in
   \file{\$(PGMRLIBD)}.  The object modules are deleted after the library
   has been updated.
   \begin{itemize}
   \item
      \file{ftn}: Update a private \textsc{fortran} library.
   \item
      \file{imp}: Update a private \code{C++} library.
   \end{itemize}

\item
   \file{\%.info} : (specific, pattern rule)
   \\ Compile a \file{.info} file.
   \begin{itemize}
   \item
      \file{doc}: Compile the \file{.info} file from the \file{.texi} file in
      the current directory or \file{\$(CODEDIR)} and leave it in the current
      directory.  Files included by the \file{.texi} file will be searched for
      first in the corresponding \file{.dir} subdirectory of the current
      directory and then of \file{\$(CODEDIR)}.
   \end{itemize}

\item
   \file{\%.dvi} : (specific, pattern rule)
   \\ Compile a \file{.dvi} file.
   \begin{itemize}
   \item
      \file{doc}: Compile the \file{.dvi} file from the \file{.texi},
      \file{.latex}, or \file{.tex} file (in that order of preference) in the
      current directory or \file{\$(CODEDIR)} and leave it in the current
      directory.

      Included files will be searched for in the corresponding \file{.dir}
      subdirectory of the current directory and of \file{\$(CODEDIR)} in that
      order.  Any \LaTeX-related \file{.bib} bibliography files
      contained in these directories will be processed by \textsc{Bib}\TeX.
   \end{itemize}

\item
   \file{\%.ps} : (specific, pattern rule)
   \\ Compile a \file{.ps} \textsc{PostScript} file.
   \begin{itemize}
   \item
      \file{doc}: Compile a \file{.ps} \textsc{PostScript} file from the
      corresponding \file{.dvi} file in the current directory.  If necessary
      the \file{.dvi} file will be generated automatically by \exeref{gmake}
      by rule-chaining the \file{\%.dvi} pattern rule.
   \end{itemize}

\item
   \code{info} : (specific)
   \\ Compile all \file{*.info} files.
   \begin{itemize}
   \item
      \file{doc}: Compile all \file{*.info} files from \file{*.texi} files in
      the current directory and leave them in the current directory.
   \end{itemize}

\item
   \code{doc} : (specific)
   \\ Compile all printable documents.
   \begin{itemize}
   \item
      \file{doc}: Compile all \file{*.texi}, \file{*.latex} and \file{*.tex}
      files in the current directory into \file{*.ps} \textsc{PostScript} files
      and leave them in the current directory.
   \end{itemize}
\end{itemize}

\subsection*{Notes}

\begin{itemize}
\item
   The implement makefile includes the system dependency lists and so may
   start slowly as it checks to see whether the list is up-to-date (regardless
   of whether the particular target uses it or not).  Inclusion of the
   dependency list can be circumvented by setting the \code{NODEP} variable
   (to anything).  This causes the makefile to start considerably faster.

   \code{NODEP} is set automatically if \exeref{gmake} is invoked from a
   directory which does not reside under \file{\$AIPSROOT}, that is, a
   programmer invokation.  However, system-oriented targets may also be
   invoked from a programmer directory, and this would cause the dependency
   analysis to be circumvented, and the dependency list to be ignored.  This
   may be legitimate if the target invoked does not actually use the
   dependency list, for example \code{chkout}, \code{cleancode} or
   \code{cleansys}.  In fact, the code distribution system sets \code{NODEP}
   explicitly when it invokes the top-level makefile for these recursive
   targets for the system (\exeref{inhale}).  However, \code{NODEP} must not
   be set for an invokation of the implement makefile for a target which does
   use the dependency list.  A proper resolution of this problem would require
   the facility for a makefile to examine its target list, but this is not
   currently possible.

\item
   If the \aipspp\ \rcs\ source code repositories are present in an
   installation all \aipspp\ makefiles access them via a symbolic link
   \file{\$AIPSROOT/rcs} which is usually set to point to \file{slave}.
   Therefore, the slave \rcs\ repositories are normally the ones consulted.
   However, it is possible to reset the \file{rcs} ``switch'' to \file{master}
   to cause \exeref{gmake} to checkout and/or rebuild \aipspp\ from the
   \file{master} repositories.  \exeref{exhale} uses this mechanism when
   constructing a new base release.  However, it requires good bandwidth to
   the master and is only feasible in Socorro.
\end{itemize}

\subsection*{Examples}

The \code{mylib} target for the implement makefile rebuilds a programmer's
private library in its entirety, including all object modules generated from
sources in \file{\$(CODEDIR)}.  To rebuild only the modules with sources in the
programmer's directory the following would suffice:

\begin{verbatim}
   cd $HOME/aips++/code/aips/implement
   gmake
\end{verbatim}

\noindent
This is the recommended way of updating a private libarary.

\subsection*{See also}

The \textsc{gnu} \code{Make} manual.\\
The \textsc{gnu} manual page for \unixexe{gmake}.\\
The unix manual page for \unixexe{ranlib}(1).\\
\aipspp\ variable names (\sref{variables}).
\exeref{gmake}, \textsc{gnu} make.\\
\filref{makedefs}, \aipspp\ makefile definitions.\\
\exeref{updatelib}, update an \aipspp\ object library.

% ----------------------------------------------------------------------------
 
\newpage
\section{\exe{reident}}
\label{reident}
\index{instantiation -- templates}
\index{library -- template instantiation}
\index{templates -- reident}
\index{reident}
 
Remake the idents in a templates list.
