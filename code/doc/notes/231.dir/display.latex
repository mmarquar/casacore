%% remove following lines when ready for system
\documentclass{article}
\usepackage{eps}
\begin{document}

\newcommand{\aipspp}{{\sf AIPS++}}
\newcommand{\glish}{{\em Glish}}

\section{Overview}

The \aipspp\ Display Library, or more properly the display package of
\aipspp, is a sophisticated class library for static and interactive
display of scientific -- predominantly astronomical -- data.  The
display package also includes an interface to \glish\ which is loaded
on-demand into the {\tt glishtk} client.\footnote{The {\tt glishtk}
client is a \glish\ proxy client which provides the Tk widgets to
\glish.}  The highest-level component of the package -- the {\tt
Viewer tool} -- is implemented as a set of \glish\ scripts, and is a
genuine \aipspp\ {\tt tool} providing display services within the
\aipspp\ environment for many kinds of data.

The purpose of this document is firstly to give the reader a
high-level outline of the Library -- an outline not possible in the
framework of the \aipspp\ class documentation -- and secondly to give
practical advice on extending the package in a number of ways, for
example to work with new display devices, to display new types of
data, or to display existing types of data in new ways.

\subsection{Design Principles}

The initial design of the Display Library was made in 1996, taking
ideas from the existing \aipspp\ display application {\tt AipsView},
and the ATNF's suite of visualisation tools.  The objective was to
adopt an object-oriented approach to visualisation so that:
\begin{itemize}
\item{the many technical and esoteric aspects of data display could be
encapsulated and therefore hidden from the application ({\tt tool})
programmer,}
\item{the support of new data types and display paradigms could be 
implemented in very high-level classes, maximising code re-use and
minimising the burden of in-depth knowledge on the part of the
application programmer, and}
\item{visualisation applications could be built up in a modular fashion, 
consistent with the \aipspp\ paradigm.}
\end{itemize}

In 1998, the Display Library design was extended to enable the
construction of visualisation tools from \glish.  Instead of using the
\aipspp\ Distributed Object (DO) system, the extension made use of the
\glish\ proxy system, and the dynamic loading capabilities of the one
existing \glish\ proxy -- {\tt glishtk}.  The first \glish\
application created using this system -- the {\tt viewer} -- is,
nevertheless, a true \aipspp\ tool which can be managed by the
\aipspp\ Tool Manager.

\section{Display Library Components}

The Display Library is written in {\sf C++}, and makes extensive use
of the basic object-oriented design concepts of encapsulation,
inheritance and polymorphism.  The Library is built upon the existing
\aipspp\ classes, and a sound knowledge of the {\em
Array, Lattice} and {\em Mathematics} classes in particular is
recommended before approaching the following sections.

\subsection{PixelCanvasColorTables and Colormaps}

Since color plays an important role in visualisation of scientific
data, it is important to provide flexible ways to allocate and use
colors within the Display Library.  To this end, a layered approach to
colors has been adopted, wherein one class -- the {\em
PixelCanvasColorTable} (for brevity, the {\em ColorTable}) -- is
primarily concerned with acquiring and managing blocks of color cells
from the underlying hardware, and a second class -- the {\em Colormap}
-- is mostly concerned with generating sets of colors to be installed
in the color cells managed by one or more ColorTable objects.  The key
to understanding color in the Display Library is to understand the
interaction between these two classes, and to more or less ignore the
hardware-dependent aspects of the ColorTable class.

The PixelCanvasColorTable class provides dynamic color cell allocation
functionality, using primitive routines appropriate to the device in
use.  For each display device provided by the Display Library, there
must be an implementation of the PixelCanvasColorTable class.  Upon
construction a ColorTable determines the color-specific capabilities
of the display device, and where appropriate, acquires control of some
number of the device's color cells.\footnote{For some devices, the
concept of color cells is invalid, and the ColorTable simply makes
things ``look like'' some number of cells has been allocated.
Differences like these -- between devices -- are encapsulated by the
PixelCanvasColorTable class.}  The number of color cells controlled by
the ColorTable should be dynamic (where possible), and under the
control of the programmer and thereby the user.  

In use, the role of the ColorTable is to dynamically allocate space
out of its own set of color cells to one or more registered Colormaps.
A Colormap provides a series of colors, on demand, which can be used
to fill a series of vacant color cells provided by a ColorTable.
Typically, such a set of colors would be used to represent a range of
data values, where the minimum data value is mapped to the first color
cell, the maximum value to the final color cell, and all other values
to cells within the available range.

The interaction between, and division of responsibilities between,
ColorTables and Colormaps is important.  One or more ColorTables can
be constructed for a given display device.  For example, a screen
display device may provide up to 256 colors, and two ColorTables, each
initially acquiring 80 colors, could be created for that screen.  The
dynamic nature of the ColorTables means that once they have been made,
they can be expanded or shrunk, provided enough colors are available.
For example, the first ColorTable in this example might then be shrunk
to 40 colors, and the second expanded to 120 colors.

In a similar way, one or more Colormaps can be registered with a
ColorTable.  That is, it is possible to register a greyscale Colormap
and a rainbow Colormap on the first of our ColorTables above.
Initially, they would each soak up 40 colors (since the ColorTable
provides 80 colors), but after the shrink operation described above,
they would soak up only 20 colors each.  See \mbox{Figure
\ref{fig:colortable}} for a pictorial representation of the hardware
color resources, the \aipspp\ ColorTable and the \aipspp\ Colormap.
In order that any images using these Colormaps are still drawn
correctly on the screen, a series of callback functions are initiated
when ColorTables and Colormaps are resized.

\begin{figure}
  \plotonesmall{1.0}{colortable.xfig.eps}
  \caption{The relationship between hardware color resources,
    \aipspp\ ColorTables and \aipspp\ Colormaps.}
  \label{fig:colortable}
\end{figure}

Finally, it is important to stress that in a single application or
tool, multiple Colormaps of the same base type can exist.  That is,
more than one ``rainbow'' Colormap can be generated, and each can be
modified independently.  Modification might include altering the
brightness or contrast, or ``stretching'' the colors in the map.  The
same Colormap can be registered on more than one ColorTable, and
furthermore may occupy a different number of color cells in each
ColorTable!  Designing an interface which allows the end-user complete
control over this extensive flexibility has proven to be challenging
however, and only a subset of the capabilities are provided at
present.

\subsection{The PixelCanvas}

The {\em PixelCanvas} is the fundamental drawing canvas of the Display
Library.  It provides an agreed-upon set of routines for drawing
graphic primitives, for controlling the ``context'' of the drawing
operations, for handling interactive events, and for supplying an
advanced caching mechanism (where possible).  For each hardware
drawing device supported by the Display Library (eg. X-Windows,
PostScript) there must be a PixelCanvas class which implements the
required routines using low-level, device-specific routines.

The graphic primitives of the PixelCanvas include points, lines,
polygons, ellipses, and images.  Multiple interfaces are provided
where convenient and possible\footnote{Note to developer: a particular
  recommendation is that this interface be pruned to perhaps provide
  just {\tt Int} and {\tt Float} interfaces.}, and these can in some
instances be implemented with templated member functions in derived
classes.  All drawing is done in the native units of the device, and
in cases where these units are not pixels -- for example, pixels are
user-defined in PostScript -- the constructor for the device-specific
PixelCanvas is expected to offer a method for (arbitrarily and
artificially) setting the resolution of the device such that
PixelCanvas drawing commands retain their meaning across all devices.
Again, the PixelCanvas makes use of encapsulation to conceal device
differences, and inheritance and polymorphism to enable the same set
of drawing commands to be used on any valid PixelCanvas.

\subsection{The WorldCanvas and its Holders}

The {\em WorldCanvas} implements a higher level of drawing
capabilities on top of the PixelCanvas class.  Multiple WorldCanvas
instances can be constructed on a single PixelCanvas, each drawing on
a subset of the entire PixelCanvas.  The bulk of the infrastructure
provided at the level of the WorldCanvas is concerned with coordinate
transformations, so that drawing on a WorldCanvas is accomplished by
the programmer in full world coordinates, or in a linear coordinate
system which mediates between the pixel coordinate system of the
PixelCanvas, and the full world coordinate system of the WorldCanvas.
Further facilities include higher-level handling of interactive
events, and data resampling and rescaling facilities.

Each WorldCanvas is constructed with reference to a specific instance
of a PixelCanvas, and occupies some fraction of the PixelCanvas.  The
position of the WorldCanvas is dynamically adjustable, and an
interface can be imagined in which the user freely positions multiple
WorldCanvases across a single PixelCanvas, in order to depict several
views of one or more datasets in a form suitable for publication, for
example.  Overlapping WorldCanvases will ultimately need a ``depth
specifier'', so that drawing order can be controlled and preserved by
the programmer and/or user.

In terms of graphic primitives, the WorldCanvas essentially replicates
those present in the PixelCanvas, and applies coordinate conversions
to input positions as necessary.

\subsection{Events and Tools}

\subsection{DisplayDatas}

\section{The Glish Connection}

\section{Programming Practicalities}

\subsection{Implementing a new PixelCanvas}

\subsection{Writing new Tools}

\subsection{Writing a DisplayData}

\subsection{Adding Agents to the GlishTk Interface}

\subsection{Extending the Viewer}

%% remove following line when ready for system
\end{document}