%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\mes}{{\em Measure}}
\newcommand{\mess}{{\em Measures}}
\newcommand{\quan}{{\em Quantity}}
\newcommand{\quans}{{\em Quantities}}
\newcommand{\val}{{\sc value}}
\newcommand{\refq}{{\sc reference}}
\newcommand{\refqs}{{\sc references}}

% Add home page navigation button
%

\htmladdtonavigation{\htmladdnormallink
  {\htmladdimg{../../gif/home.gif}}{{../../html/aips++.html}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

This guide gives a short overview of the background and use of the
\mes\ module in C++. Detailed information can be found in the
\mess\ module description, and in the individual header files of the
classes in this module.

Section 2 explains what a \mes\ consists of, and why; section 3
discusses conversion; section 4 some notes on efficient use and
section 5 gives the common interface of \mess\ and their values. Appendices 
give some details per \mes, and also some information on \quans.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Background}

Currently the following measures exist:
\begin{description}
%{1}{}
%{\setlength{\labelwidth}{60em}}
\item[$Epoch$] a high precision epoch, a moment in time
\item[$Position$] a 3-dimensional position vector, in general indicating
a position w.r.t. Earth
\item[$Direction$] a direction in space (i.e. a position of unit length)
\item[$Frequency$] the frequency of an electro-magnetic wave
\item[$Doppler$] the redshift of an object
\item[$RadialVelocity$] velocity along a direction
\item[$EarthMagneticField$] the earth magnetic field vector 
\item[$Baseline$] a direction with a length
\item[$uvw$] a $u,v,w$ coordinate: a baseline projected on some plane
\end{description}


A specific \mes\ class is indicated with an $M$, e.g. a direction measure is
an $MDirection$.

A \mes\ consists of a \val\ and a \refq. The \val\ of a \mes\ is a vector
of double floating point numbers, in some internal format. The \val\ is
called a {\em MeasValue}, and specific ones are indicated with the
letters $MV$, e.g. $MVDirection$
\footnote{Note that it is an
unfortunate circumstance that there exist the classes $MVTime$ and
$MVAngle$, which are not {\em MeasValues}, but only formatting classes
for times and angles.}.
Appendix A gives the various internal values.

A \val\ can be constructed in many different ways. An $MVDirection$
can, e.g. be constructed from 2 angles or from 3 direction cosines; an
$MVFrequency$ from a wavelength or the wave energy.

Some \mess\ can often also be obtained from a catalog, especially a list of
observatories, a source list and a spectral line list. They can be
obtained as: \\
\\
\hspace{.05\linewidth}
\begin{minipage}[t]{.9\linewidth}
\begin{verbatim}
    MDirection source;
    MFrequency line;
    MPosition obs;
    if (MeasTable::Observatory(obs, "ATCA")) {};
    if (MeasTable::Line(line, "HI")) {};
    if (MeasTable::Source(source, "0008-421")) {};
\end{verbatim}
\end{minipage}
\\

The \refq\ consists of up to 3 {\em fields}:
\begin{itemize}
\item a {\em reference code}, describing how the \val\ should be
interpreted. This field is mandatory, and has an enumerated value (see
Appendix A for the possible codes). Examples are:
\begin{itemize}
\item {\tt MDirection::J2000}
\item {\tt MDirection::AZEL}
\item {\tt MEpoch::TAI}
\item {\tt MEarthMagnetic::DEFAULT}
\end{itemize}
In some cases the code has all the available information to be able to
interpret the \val\ (like the {\tt MDirection::J2000}). In other cases
the information is not sufficient. An example is the {\tt
MDirection::AZEL}. If you have measured some {\em AZEL} values, and
are only interested in say a pointing model for the telescope, the
{\tt MDirection::AZEL} is sufficient information. However, if you want
to convert the measured {\em AZEL} into a {\em J2000} right ascension
and declination, it is necessary to know where your telescope is, and
what the epoch of the observation is. This can be specified in 
\item a {\em frame}. The {\em frame} is a {\em MeasFrame} class
object, and can contain \mess\ describing the epoch, the position on
Earth, the direction in which you are observing (for Doppler
calculations), the rest frequency of a spectral line and a table
describing the detailed orbit of a non-standard solar system object
(like a comet). The {\em frame} can be filled with the {\em MeasFrame}
constructor, or with {\em MeasFrame} {\tt set()} methods.
\item an optional {\em offset}. In some cases it can be advantageous
to specify an offset. An example could be 0h on a specific date, with
the actual {\em Epoch} only specifying the time since that point in
time. Note that offsets are not very useful for {\em Directions},
since directions are always vectors of unit lengths. However, special
{\tt offset} methods exist for directions.
\end{itemize}

A \refq\ is created as a specialised {\em MeasRef} object, using the
{\tt Measure::Ref} alias (e.g. {\tt MDirection::Ref}). A full
reference could be:\\
\\
\hspace{.05\linewidth}
\begin{minipage}[t]{.9\linewidth}
\begin{verbatim}
   // A time in MJD
   MEpoch epoch(Quantity("50500.5d"), MEpoch::UTC);
   MPosition obs;
   MeasTable::Observatory(obs, "WSRT");
   MeasFrame frame(obs, epoch);
   MDirection::Ref ref(MDirection::VENUS, frame);
\end{verbatim}
\end{minipage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conversion}
\begin{sloppypar}
\mess\ can be converted from one \refq\ into another \refq. E.g. from
an {\tt MDirection::J2000} direction coordinate into an {\tt
MDirection::AZEL} coordinate; or from an {\tt MEpoch::UTC} into an 
{\tt MEpoch::TAI}. Conversion objects are {\tt MeasConvert} objects,
using the {\tt MEasure::Convert} alias (e.g. {\tt
MDirection::Convert}. The conversion object needs at least a {\em from}
\refq\ and a  {\em to} \refq.
\end{sloppypar}

Example: \\
\\
\hspace{.05\linewidth}
\begin{minipage}[t]{.95\linewidth}
\begin{verbatim}
   MDirection::Convert(MDirection::Ref(MDirection::VENUS,
                                       frame),
                       MDirection::Ref(MDirection::J2000));
\end{verbatim}
\end{minipage}
\\

{\em Note} that if a {\em frame} is necessary, it suffices to give it
with either one of the two \refqs. Unless, of course, they are
different for the two \refqs, like converting the {\tt AZEL} at one
telescope to that at another.

The {\em from} \refq\ can also be specified as a complet \mes. In that
case that \val\ of the \mes\ will act as the {\em default} \val\ to be
converted.

Constructing a conversion object will set up a series of conversions
that have to be done to get from the {\em from} to the {\em to} \refq. This
state-machine like approach is to be able to use less than the
required odd 400 conversion routines for say 20 different allowable
reference codes.

The conversion object is executed with the () operator. The actual
conversion done depends on the argument of the operator:
\begin{itemize}
\item {\em none}: use the default value of the Measure specified in the
constructor (or using a {\tt set()} method).
\item {\em MeasVale}: convert it to a \mes\ using the {\em from}
reference of the object
\item {\em Measure}: re-initialise the conversion object, and do the
conversion with the new default value (since the \refq\ has changed!).
\end{itemize}

If the conversion needs information, it will cache anything it
calculates, either in the conversion object (like calculated {\em
Nutation}), or in the {\em frame} (like e.g. the sidereal time of a
frame MEpoch specified in UTC). This information will be re-useed if
possible and feasable in subsequent conversions with the same
conversion object or using the same frame.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Efficiency}

The efficiency of the use of the \mess\ and related classes can vary
greatly. By using the appropriate interface, by fine-tuning with the
aid of {\tt aipsrc} variables, and by making sure the caching system
is used optimally, there can be a large reduction in resource use.

\subsection{Measure or MeasValue}

It is not always necessary to use a full-fledged \mes. It often
suffices to use a {\em MeasValue} (or maybe even a \quan\ or just a
simple {\em Double}.

As an example, consider a frequency container object:
\begin{itemize}
\item if you have some box that produces a value that is always in
$GHz$, and that has to be passed-on as-is without any further
information, a {\em Double} is sufficient
\item if the value you have has to be converted to some other
frequency unit (like MHz or so) before being used, use a \quan. The
only knowledge necessary is the units 
\item if you would like the value be represented in other ways
to represent an electro-magnetic wave (like wavelength, time, energy,
impulse, angle/time, time), use an {\em MVFrequency}, which knows that
the value has the properties of an electro-magnetic wave (in addition
to the units)
\item if you would like to know what the frequency really represent
(a spectral rest frequency; a frequency as observed in a telescope; a
frequency as would be observed from the local standard of rest;
\ldots), and if you are going to use that information in one way or another
(display, conversion, archive, \ldots) use an {\em MFrequency} as value
container
\end{itemize}
Similar arguments can be used for the other \mess.

\subsection{Re-use the effort of frame}

From the point of view of the programmer, a {\em frame} is just a
container of \mess\ to indicate when, where, in what
direction and at what frequency a certain \mes\ was made or referred
to. However, in actual fact it is also an engine and cache for a lot
of calculations. Imagine that you want to convert from right-ascension
and declination to hour-angle and declination, and that you have
provided an epoch in $UTC$ in the {\em frame}. The actual conversion
object will request (probably among other things), the sidereal time
from the frame. The first request will set up a conversion object
within the frame (from $UTC$ to $LAST$) and cahe it for later
use. After that it will use this conversion object to obtain the
sidereal time, and cache the result (for maybe a subsequent call). The
conversion needs nutation, polar motion and a few other
calculations. Again, all of these are cached for subsequent use in
other calls to the frame for information.

Efficient use of \mess\ is only possible if the lifetime of a {\em
frame} is as long as possible. Which suggests that in many cases a
frame should be created at the highest level possible (maybe even
globally). Re-use of a {\em farme}, e.g. for a different time, is made
possible by the {\tt set()} methods, e.g. $set(MEpoch)$, which will
try to minimize the re-calculations necessary.

\subsection{Re-use of conversion objects}

Similar to the frame discussed in the previous section, a conversion
object (e.g. {\tt MDirection::Convert}) is a repository of the
necessary state-machine to make the conversion possible, and any
intermediate calculation results. To make efficient use of this
information, the same conversion object should be used if more than
one conversion of the same type has to be done.

\subsection{Specialised conversion engines}

Although the official {\tt MeasConvert} objects are very versatile,
using them can be quite a job. For that reason a set of specialised
``Conversion engines'' have been put together for easy use. The three
engines available at the moment are described in the following
paragraphs. They have all a basic format:
\begin{itemize}
\item a constructor is used to create an engine object. The object
knows (either through constructor, or through the use of {\tt set()}
methods) about the conversions to be done
\item the {\em ()} operator is used to convert a value the appropriate
way.
\end{itemize}

\subsubsection{EarthMagneticMachine}

The {\em EarthMagneticMachine} calculates the Earth' magnetic field in
a ceratin direction at a certain height above the Earth' surface.

The machine object's constructor needs in principle:
\begin{itemize}
\item a direction {\em reference code} to be able to interpret input
direction values
\item height above the Earth' surface
\item position (of observation point) on Earth
\item epoch of observation (the $IGRF$ model used is time dependent)
\end{itemize}

The $()$ operator will produce the line-of-sight component of the
magnetic field (see the header files for details). Other methods exist
to get the complete magnetic field; the longitude of the point
specified and the position on Earth of the point.
The following example calculates the magnetic field at 200$km$ height
at the Compact Array:
\begin{verbatim}
   // Define a time/position frame
   MEpoch epo(MVEpoch(MVTime(98,5,16,0.5).day()));
   MPosition pos;
   MeasTable::Observatory(pos, "ATCA");
   MeasFrame frame(epo, pos);
   // Note that the time in the frame can be changed later
   // Set up a machine
   EarthMagneticMachine exec(MDirection::B1950,
                             Quantity(200, "km"), frame);
   // Given a current observational direction
   MDirection indir(Quantity(3.25745692, "rad"),
                    Quantity(0.040643336,"rad"),
                    MDirection::Ref(MDirection::B1950));
   // The field in this direction is calculated
   exec.calculate(indir.getValue());
   // Show some data
   cout << "Parallel field: " << exec.getLOSField() <<
           " nT" << endl;
   cout << "Sub-ionosphere long: " << exec.getLong("deg") <<
           endl;
\end{verbatim}


\subsubsection{VelocityMachine}
\begin{sloppypar}
The velocity machine converts between frequencies and velocities (or
$vice$ $versa$). This
machine has been developed to aid in the, especially for the beginning
user of \mess, intricate way {\em RadialVelocity}, {\em Doppler} and
{\em Frequency} are connected. The machine converts between $Doppler$
and $Frequency$ values.
\end{sloppypar}
The constructor of the machine needs:
\begin{itemize}
\item a frequency reference (e.g. {\tt MFrequency::LSR}), including a
possible offset and frame
\item preferred frequency units (e.g. $cm$ or $GHz$)
\item velocity reference (e.g. {\tt MDoppler::OPTICAL}), including a
possible offset
\item preferred velocity units (e.g. $AU/a$)
\item the rest frequency used for the conversion, given as an {\tt
MVFrequency}
\end{itemize}

The $()$ operator has an {\tt MVFrequency}, an {\tt MVDoppler} or a
{\tt Quantity} as argument. Depending on if it is a velocity or a
frequency, the argument is converted to the other representation. {\tt
makeFrequency} and {\tt makeVelocity} exist to create a vector of
velocities or frequencies from a vector of Doubles.

An example:
\begin{verbatim}
      // Define a time/position frame
      MEpoch epo(MVEpoch(MVTime(98,5,16,0.5).day()));
      MPosition pos;
      MeasTable::Observatory(pos, "ATCA");
      MeasFrame frame(epo, pos);
      //
      // Note that the time in the frame can be changed later
      // Specify the frequency reference
      MFrequency::Ref fr(MFrequency::LSR);
      //
      // Specify the velocity reference
      MDoppler::Ref vr(MDoppler::OPT);
      //
      // Specify the default units
      Unit fu("eV");
      Unit vu("AU/a");
      //
      // Get the rest frequency
      MVFrequency rfrq(QC::HI);
      //
      // Set up a machine (no conversion of reference frame)
      VelocityMachine exec(fr, fu, rfrq, vr, vu, frame);
      //
      // or as (with conversion of reference frame it
      // could have been)
      // VelocityMachine exec(fr, fu, rfrq, vr, vu,
      //                      MFrequency::TOPO, frame);
      // Given a current observational frequency of 
      //    5.87432837e-06 eV
      // its velocity will be (in AU/yr)
      cout << "Velocity: " <<
              exec.makeVelocity(5.87432837e-06 << endl;
      //
      // Introducing an offset
      MFrequency foff(MVFrequency(Quantity(5.87432837e-06,
                      "eV")), MFrequency::LSR);
      //
      // and setting it in the reference, and regenerating
      // machine:
      fr.set(foff);
      exec.set(fr);
      //
      // the following will give the same result:
      cout << "Velocity: " << exec.makeVelocity(0.0)
           << endl;
\end{verbatim}

\subsubsection{UVWMachine}

The {\em UVWMachine} can convert $UVW$-coordinates between coordinate
systems. In addition it can provide the phase rotation necessary on
the data to have a new fringe-stopping center. A simple conversion of
$UVW$ coordinates will be executed if only the coordinate reference
frame is changed (e.g. from a $J2000$ to a $Galactic$ or an $AzEl$
coordinate system). If also the actual position on the sky is changed,
the phase rotation necessary on the data is provided as well. Fringe
stopping centers can be centered on other bodies as well (e.g. a
planet). Read the caveats in the detailed help file.

The constructor of the machine needs the following input:
\begin{itemize}
\item an input {\tt MDirection} specifying the original fringe
stopping center's position and reference frame
\item an output {\tt reference code} to indicate the output reference
frame of the $UVW$ coordinates; or an output {\tt MDirection}
indicating both the new fringe stopping center and its reference position. 
\end{itemize}

The output of the machine can be one or all of the following:
\begin{itemize}
\item a rotation matrix that can be used to transpose the
$UVW$-coordinates
\item a vector that can be used to produce the necessary phase
rotation
\item actual conversion of a set of input $UVW$ points
\item actual vector of phase rotations for a set of $UVW$ points
\end{itemize}

Example:
\begin{verbatim}
   // Given a current phase stopping Center
   MDirection indir(Quantity(3.25745692, "rad"),
                    Quantity(0.040643336,"rad"),
                    MDirection::Ref(MDirection::B1950));
   // Conversion to J2000 is set by:
   UVWMachine uvm(MDirection::Ref(MDirection::J2000), indir);
   // The rotation matrix to go to new UVW is obtained by:
   RotMatrix rm(uvm.rotationUVM());
   // If an UVW specified:
   MVPosition uvw(-739.048461, -1939.10604, 1168.62562);
   // This can be converted by e.g.:
   uvw *= rm;
   // Or, alternatively, by e.g.:
   uvm.convertUVW(uvw);
\end{verbatim}



\subsection{Specifying details}

\section{Interface}

\subsection{Getting values from a Measure}

\subsection{Getting values from a MeasValue}

\subsection{Can I obtain information from the MeasFrame?}

\appendix

\section{Details for individual Measures}

\section{Use of units and quantities}
