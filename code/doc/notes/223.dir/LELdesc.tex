
\externallabels{../../user/Refman}{../../user/Refman/labels.pl}

\section{Introduction}
The Lattice Expression Language (LEL) makes it possible to do
arithmetic on lattices (in particular on images) in AIPS++.
An expression can be seen as a lattice (or image) in itself. It
can be used in any operation where a normal image is used.

In short the following functionality is supported:
\begin{itemize}
\item The common mathematical, comparison, and relational
      \htmlref{operators}{LEL:OPERATORS}.
\item An extensive list of mathematical and logical
      \htmlref{functions}{LEL:FUNCTIONS}.
\item Mixed \htmlref{data type}{LEL:DATATYPES} arithmetic
      and automatic data type promotion.
\item \htmlref{Masking}{LEL:CONDITIONS} using boolean expressions.
\item Propagation of \htmlref{masks}{LEL:MASKS} through an expression.
\item Support of image \htmlref{regions and masks}{LEL:REGIONS}.
\end{itemize}

The first section explains the syntax.
The last sections show the interface to LEL using Glish or C++.
The Glish interface makes it possible to embed Glish
variables and expressions in a LEL command.

LEL operates on lattices, which are a generalization of arrays.
As said above a particular type of lattice is an image; they
will be used most often.
Because lattices can be very large, an expression is only evaluated
when a chunk of its data is requested. This is similar to reading
only the requested chunk of data from a disk file.

LEL is quite efficient and can therefore be used well in
C++ and glish code. However, it can never be as efficient as
carefully constructed C++ code. 

\htmladdnormallink{Note 216}{../216/216.html} gives a detailed
description how LEL is implemented using various C++ classes.


\section{\label{LEL:EXPRESSIONS}Expressions}
A LEL expression can be as simple or as complex as one likes
using the standard
\htmlref{arithmetic, comparison, and logical operators}{LEL:OPERATORS}.
Parentheses can be used to group subexpressions.
\\The operands in an expression can be
\htmlref{lattices}{LEL:LATTICES},
\htmlref{constants}{LEL:CONSTANTS},
\htmlref{functions}{LEL:FUNCTIONS}, and
\htmlref{condition masks}{LEL:CONDITIONS}.
\htmlref{image regions and masks}{LEL:REGIONS}.
E.g.
\begin{verbatim}
  lat1 + 10
  lat1 + 2 * max(lat2,1)
  amp(lat1, lat2)
  lat1 + mean(img[region1])
  lat1 + mean(lat2[lat2>5 && lat2<10])
\end{verbatim}
The last example shows how a boolean expression can be used to form
a mask on a lattice. Only the pixels fulfilling the condition will be
used when calculating the mean.

In general the result of a LEL expression is an lattice, but it
can be a scalar too. If a scalar, it will be handled correctly
by C++ and glish functions using it as the source in, say, an
assignment to another lattice.

LEL fully supports masks. In almost all cases the mask of a
subexpression is formed by and-ing the masks of its operands.
It is fully explained in a \htmlref{later section}{LEL:MASKS}.


\label{LEL:DATATYPES}
LEL supports the following data types:
\begin{description}
  \item[ \textbf{Bool}]
  \item[ \textbf{Float}] single precision real (which includes integers)
  \item[ \textbf{Double}] double precision real
  \item[ \textbf{Complex} ] single precision complex
  \item[ \textbf{DComplex} ] double precision complex
\end{description}
All these data types can be used for scalars and lattices.
\\LEL will do automatic data type promotion when needed. E.g. when
a Double and a Complex are used in an operation, they will be promoted
to DComplex. It is also possible to promote explicitly using the
conversion functions (FLOAT, DOUBLE, COMPLEX and DCOMPLEX).
These functions can also be used to demote a data type
(e.g. convert from Double to Float), which can sometimes
be useful for better performance.

\textbf{Region} is a specific data type. It indicates a region of any type
(in pixel or world coordinates, relative, fractional).
A region can only be applied to a lattice subexpression using
operator \texttt{[]}.


\subsection{\label{LEL:CONSTANTS}Constants}
Scalar constants of the various data types can be formed as follows
(which is similar to Glish):
\begin{itemize}
  \item A Bool constant can be given as T or F
        (meaning true and false respectively).
  \item A Float constant can be any integer or floating-point number. E.g.
    \begin{verbatim}
    3
    3.14
    3.14e-2
    \end{verbatim}
  \item A Double constant is a floating-point number using a D for the
    exponent. One can also use the \texttt{DOUBLE} function. E.g.
    \begin{verbatim}
    1d2
    3.14d-2
    double(2)
    \end{verbatim}
  \item The imaginary part of a Complex or DComplex constant is formed
    by a Float or Double constant immediately followed by a lowercase
    \textbf{i}. A full complex
    constant is formed by adding another constant as the
    real part. E.g.
    \begin{verbatim}
    1.5 + 2i
    2i+1.5            is identical
    \end{verbatim}
    Note that a full complex constant has to be enclosed
    in parentheses when, say, a multiplication is performed on it. E.g.
    \begin{verbatim}
    2 * (1.5+2i)
    \end{verbatim}
\end{itemize}
The functions \texttt{pi()} and \texttt{e()} should be
used to specify the constants pi and e. They form a Double constant,
so when using e.g. pi with a Float lattice, it could make a lot of sense
to convert pi to a Float. Otherwise the lattice is converted to a
Double, which is time-consuming. However, one may have very valid
reasons to convert to Double, e.g. to ensure that the calculations are
accurate enough.

\subsection{\label{LEL:OPERATORS}Operators}
The following operators can be used (with their normal meaning and
precedence):
\begin{description}
  \item[] Unary \textbf{+} and \textbf{-}
       \\Can not be used with Bool operands.
       They have a higher precedence than the binary operators.
       E.g. \texttt{-3}\verb+^+\texttt{2} results in \texttt{9}.
  \item[] Unary \textbf{!}
       \\Logical NOT operator.
       Can only be used with Bool operands.
       \\For a region it forms the complement.
  \item[] Binary \textbf{$\wedge$, *, /, \%, +}, and \textbf{-}
       \\\% is the modulo operator.
       E.g. \texttt{3\%1.4} results in \texttt{0.2} and
       \texttt{-10\%3} results in \texttt{-1}.
       \\\verb+^+ is the power operator.
       Note that because of the precedence rules
       \texttt{-3}\verb+^+\texttt{2} results in \texttt{9}.
       \\All operators are left-associative, except \verb+^+ which is
       right-associative; thus
       \texttt{2}\verb+^+\texttt{1}\verb+^+\texttt{2} results in \texttt{2}.
       \\Operator \% can only be used for real operands, while the others
       can be used for real and complex operands.
        \\Operator \textbf{-} can also be used for regions. It forms
        the difference of the left and right operand.
  \item[] \textbf{==, $!=$, $>$, $>=$, $<$}, and \textbf{$<=$}
       \\For Bool operands only $==$ and $!=$ can be used.
       \\A Bool operand cannot be compared with a numeric operand.
       \\The comparison operators use the norm for complex values.
  \item[] \textbf{\&\&} and \textbf{$\mid\mid$}
       \\Logical AND and OR operator. 
       \\These operators can only be used with Bool operands.
       \\When used on a region \textbf{\&\&} forms the intersection,
       while \textbf{$\mid\mid$} forms the union.
\end{description}
\begin{description}
  \item The precedence order is:
       \\unary \texttt{+, -, !}
       \\\verb+^+
       \\\texttt{*, /, \%}
       \\\texttt{+, -}
       \\\texttt{$==, !=, >, >=, <, <=$}
       \\\texttt{\&\&}
       \\\texttt{$\mid\mid$}
\end{description}

\subsection{\label{LEL:FUNCTIONS}Functions}
In the following tables the function names are shown in uppercase,
while the result and argument types are shown in lowercase.
Note, however, that function names are case-insensitive.
All functions can have scalar and/or lattice arguments.
\\When a function can have multiple arguments (e.g. atan2), the
operands are automatically promoted where needed.

\subsubsection{Mathematical functions}
Several functions can operate on real or complex arguments.
The data types of such arguments are given as 'numeric'.
\begin{description}
  \item[ \texttt{Double PI()}] Returns the value of \textbf{pi}.
  \item[ \texttt{Double E()}] Returns the value of \textbf{e}.
  \item[ \texttt{numeric SIN(numeric)}]
  \item[ \texttt{numeric SINH(numeric)}]
  \item[ \texttt{real ASIN(real)}]
  \item[ \texttt{numeric COS(numeric)}]
  \item[ \texttt{numeric COSH(numeric)}]
  \item[ \texttt{real ACOS(real)}]
  \item[ \texttt{real TAN(real)}]
  \item[ \texttt{real TANH(real)}]
  \item[ \texttt{real ATAN(real)}]
  \item[ \texttt{real ATAN2(real y, real x)}]
       Returns \texttt{ATAN(y/x)} in correct quadrant.
  \item[ \texttt{numeric EXP(numeric)}]
  \item[ \texttt{numeric LOG(numeric)}] Natural logarithm.
  \item[ \texttt{numeric LOG10(numeric)}]
  \item[ \texttt{numeric POW(numeric, numeric)}] The same as operator \verb+^+.
  \item[ \texttt{numeric SQRT(numeric)}]
  \item[ \texttt{complex COMPLEX(real, real)}]
       Create a complex number from two reals.
  \item[ \texttt{complex CONJ(complex)}]
  \item[ \texttt{real REAL(numeric)}] Real value itself or
    real part of a complex number.
  \item[ \texttt{real IMAG(complex)}] Imaginary part of a complex number.
  \item[ \texttt{real NORM(numeric)}]
  \item[ \texttt{real ABS(numeric),  real AMPLITUDE(numeric)}]
  \item[ \texttt{real ARG(numeric),  real PHASE(numeric)}]
  \item[ \texttt{numeric MIN(numeric, numeric)}]
  \item[ \texttt{numeric MAX(numeric, numeric)}]
  \item[ \texttt{Float SIGN(real)}]
       Returns -1 for a negative value, 0 for zero, 1 for a positive value.
  \item[ \texttt{real ROUND(real)}]
       Rounds the absolute value of the number.
       \\E.g. \texttt{ROUND(-1.6) = -2}.
  \item[ \texttt{real FLOOR(real)}]
       Works towards negative infinity.
       \\E.g. \texttt{FLOOR(-1.2) = -2}
  \item[ \texttt{real CEIL(real)}] Works towards positive infinity.
  \item[ \texttt{real FMOD(real, real)}] The same as operator \%.
\end{description}
Note that the trigonometric functions need their arguments in radians.

\subsubsection{Scalar result functions}
The result of these functions is a scalar.
\begin{description}
  \item[ \texttt{double NELEMENTS(anytype)}]
    Return number of elements in a lattice (1 for a scalar).
  \item[ \texttt{double NDIM(anytype)}]
    Return dimensionality of a lattice (0 for a scalar).
  \item[ \texttt{double LENGTH(anytype, double axis)}]
    Return length of a lattice axis (returns 1 for a scalar or if axis
    exceeds number of axes). Axis number is 1-relative.
  \item[ \texttt{Bool ANY(Bool)}] Is any element true?
  \item[ \texttt{Bool ALL(Bool)}] Are all elements true?
  \item[ \texttt{Double NTRUE(Bool)}] Number of true elements.
  \item[ \texttt{Double NFALSE(Bool)}] Number of false elements.
  \item[ \texttt{numeric SUM(numeric)}] Return sum of all elements.
  \item[ \texttt{numeric MIN(numeric)}] Return minimum
    of all elements.
  \item[ \texttt{numeric MAX(numeric)}] Return maximum
    of all elements.
  \item[ \texttt{numeric MEAN(numeric)}]
    Return mean of all elements.
  \item[ \texttt{numeric VARIANCE(numeric)}]
    Return variance
    \\(\texttt{sum((a(i) - mean(a))**2) / (nelements(a) - 1)}).
    \\All calculations are done in double precision.
  \item[ \texttt{numeric STDDEV(numeric)}]
    Return standard deviation (the square root of the variance).
  \item[ \texttt{real AVDEV(numeric)}]
    Return average deviation.
    \\(\texttt{sum(abs(a(i) - mean(a))) / nelements(a)}).
    \\All calculations are done in double precision.
\end{description}

\subsubsection{Miscellaneous functions}
\begin{description}
  \item[ \texttt{anytype IIF(Bool, anytype, anytype)}]
    The first argument is a boolean expression. If an element in
    it is true, the corresponding element from the second argument is
    taken, otherwise from the third argument. It is similar to the
    ternary \texttt{?:} construct in C++. E.g.
    \begin{verbatim}
    iff (lat1>0, lat1, 0)      same as max(lat1,0)
    iff (sum(lat1)>0, lat1, lat2)
    \end{verbatim}
    The examples shows that scalars and lattices can be freely mixed.
    When all arguments are scalars, the result is a scalar. Otherwise
    the result is a lattice.
\end{description}

\subsubsection{Conversion functions}
\begin{description}
  \item[ \texttt{Float FLOAT(real)}]
    Convert to single precision.
  \item[ \texttt{Double DOUBLE(real)}]
    Convert to double precision.
  \item[ \texttt{Complex COMPLEX(numeric)}]
    Convert to single precision complex.
    If the argument is real, the imaginary part is set to 0.
  \item[ \texttt{DComplex DCOMPLEX(numeric)}]
    Convert to double precision complex.
    If the argument is real, the imaginary part is set to 0.
\end{description}

\subsection{\label{LEL:LATTICES}Lattice names}
When a lattice (e.g. an image) is used in an expression, its name
has to be given. The name can be given as such if it consists of
the characters \texttt{-}\texttt{.}\texttt{\$}\texttt{\~\ }
and alphanumeric characters.
\\If the name contains other characters or if it is a reserved word
(currently only T and F are reserved), it has to be escaped.
Escaping can be done by preceeding the special characters with a
backslash or by enclosing the string in single or double quotes.
E.g.
\begin{verbatim}
  ~/myimage.data
  ~/myimage.data\-old
  '~/myimage.data-old'
\end{verbatim}
Note that when LEL is used in glish, it is also possible to use
a glish image variable as a lattice operand (e.g. \texttt{\$im}).
This is explained in the section describing the
\htmlref{glish binding}{LEL:GLISHC}. It means that in glish a
name starting with a \texttt{\$} should be escaped too.

An image can have zero or more masks indicating if a pixel is good or
bad. One mask can be designated as the default mask, which will
by default be applied to the image. It is possible to give a suffix
to the image name telling if no mask or another mask should be used.
The suffix is a colon followed by the word /texttt{nomask}
or the name of the alternative mask. Note that the suffix should
not be enclosed in the possible quotes of the image name, otherwise
it is part of the image name.
\begin{verbatim}
  myimage.data
  myimage.data:nomask
  'myimage.data:othermask'
\end{verbatim}
The first example uses the default mask (if the image has one).
\\The second example uses no mask.
\\The third example uses mask \texttt{othermask}.
\\Note that if the image name is enclosed in quotes, the mask name
should be enclosed too. It means that a colon cannot be part of
an image name.

Note that below it is explained that a region (or mask) can
be applied using operator \texttt{[]}. It means that the third
example is equivalent to
\begin{verbatim}
  myimage.data:nomask[othermask]
\end{verbatim}
but is far easier to write.

\subsection{\label{LEL:CONDITIONS}Lattice Condition Mask}
Lattices can have a mask. Examples are a mask of good pixels in an
image (as explained in the \htmlref{previous section}{LEL:LATTICES})
or the mask indicating the pixels of a region within its bounding box
(e.g. for a circle) as explained in the \htmlref{next section}{LEL:REGIONS}.

Apart from such input masks, it is also possible to create a mask
using operator \texttt{[]} and a boolean expression. E.g.
\begin{verbatim}
  sum( lat1[lat1<5 && lat1>10] )
\end{verbatim}
creates a mask for lat1 indicating that only its elements fulfilling
the condition should be taken into account in the \texttt{sum}
function.
\\Note that the mask is local to that part of the expression. So in
\begin{verbatim}
  sum( lat1[lat1<5 && lat1>10] ) + sum(lat1)
\end{verbatim}
the second \texttt{sum} function takes all elements into account.
\\Masking can also be applied to expressions and it is recursive.
\begin{verbatim}
  (lat1+lat2)[lat3<lat4]
  sum( lat1[lat1<5][lat1>10] )
  (lat1 + lat2[lat3<lat4]) [lat1<5]
\end{verbatim}
The second example shows the recursion (which ANDs the masks).
It is effectively a (slower) implementation of the
first example in this section.

When a lattice has a mask of itself, the mask formed by the condition
is and-ed with the lattice mask. It is explained in more detail in the
section discussing \htmlref{mask propagation}{LEL:MASKS}.

\section{\label{LEL:REGIONS}Regions}
A region of any type can be applied to a lattice using operator[].
It results in a lattice with the shape of the region's bounding box.
If the region or the lattice has a mask, they are and-ed to form
the result's mask.

All types of regions supported in AIPS++ can be used, thus:
\begin{itemize}
\item regions in pixel or world coordinates
\item in absolute, relative and/or fractional units
\item basic regions box, ellipsoid, and polygon
\item masks
\item compound regions union, intersection, difference, and complement.
\item extension of a region or group of regions to higher dimensions
\end{itemize}
The documentation in the classes
 \htmladdnormallink{LCRegion}{../../trial/implement/Lattices/LCRegion.html},
 \htmladdnormallink{LCSlicer}{../../trial/implement/Lattices/LCSlicer.html}, and
 \htmladdnormallink{WCRegion}{../../trial/implement/Images/WCRegion.html})
gives you more information about the various regions.

At this moment a region can not be defined in LEL itself. It is
only possible to use regions predefined in an image or another table.
When using glish (as will normally be done), it is also possible
to use a region defined in glish using the \$-notation. This is
explained in more detail in the section discussing the
\htmlref{interface to LEL}{LEL:GLISHC}.

A predefined region can be used by specifying its name.
There are three ways to specify a region name:
\begin{enumerate}
\item \texttt{tablename::regionname}
  \\The region is looked up in the given table (which will
  usually be an image).
\item \texttt{::regionname}
  \\The region is looked up in the last table used in the expression.
\item \texttt{regionname}
  \\Is equivalent to above. However, there is no syntactical
  difference between the name of a region and a lattice/image.
  Therefore LEL will first try if the name represents a lattice or
  image. If not, the name is supposed to be a region name.
  The prefix \texttt{::} in the previous way tells that the name
  should only be looked up as a region.
\end{enumerate}
E.g.
\begin{verbatim}
  myimage.data[reg1]
  (myimage.data - otherimage)[::reg1]
  (myimage.data - otherimage)[myimage.data::reg1]
\end{verbatim}
In the first example region \texttt{reg1} is looked up in image
\texttt{myimage.data} It is assumed that \texttt{reg1} is not the
name of an image or lattice.
\\In the second example it is stated explicitly that \texttt{reg1}
is a region. It is looked up in \texttt{otherimage}.
\\In the third example the region is looked up in \texttt{myimage.data}.
\\Note that the last examples also show that a region can be applied
to a subexpression.

A union, intersection, difference and complement of regions
could be stored as a region. It is also possible to form a union,
etc. in LEL itself. However, that can only be done if the regions
have the same type (i.e. both in world or in pixel coordinates).
The following operators can be used:
\\ \texttt{reg1 || reg2} to form the union.
\\ \texttt{reg1 \&\& reg2} to form the intersection.
\\ \texttt{reg1 - reg2} to form the difference.
\\ \texttt{!reg1} to form the complement.

The normal AIPS++ rules are used when a region is applied:
\begin{itemize}
\item A region in world or relative coordinates can only be applied
to an image (or a subexpression resulting in an image). Otherwise
there is no way to convert it to absolute pixel coordinates.
\item The axes of a region in world coordinates have to be axes in
the image (subexpression). However, the region can have fewer axes.
\item If a region has fewer axes than the image or lattice
the region is automatically extended to the full image
by taking the full length of the missing axes.
\end{itemize}

\section{\label{LEL:MASKS}Mask Propagation}
As explained in the previous sections lattices can have a mask.
Examples are a mask of good pixels in an image or the mask indicating
the pixels of a region within its bounding box (e.g. for a circle).
Furthermore a mask can be created using a condition and
operator \texttt{[]}.

Masks are combined and propagated throughout an expression.
E.g. when two lattices are added, the mask of the result is formed
by and-ing the masks of the two lattices.
\\In general the mask of a subexpression is formed by and-ing
the masks of the operands. This is true for e.g. +, *, \texttt{atan2},
etc..

There are a few special cases:
\begin{itemize}
\item
The mask created by \texttt{operator[condition]} is formed by and-ing the
condition result, the mask of the result, and the mask of the subexpression
where the condition is applied to. E.g. suppose \texttt{lat1} and
\texttt{lat2} have a mask. Then in
\begin{verbatim}
  sum( lat1[lat2<5] )
\end{verbatim}
the \texttt{sum} function will only sum those elements for which
the mask of \texttt{lat1} and \texttt{lat2} is valid and for which
the condition is true.

\item
The logical AND operator forms the resulting mask by looking at
the result and the masks of the operands. If an element in an
operand is false and it has a valid mask, than the resulting
element is also false with a valid mask. The value and the mask of
that element in the other operand are not important anymore.
It is, in fact, 3-valued logic with the values TRUE, FALSE, and UNDEFINED.

\item
The logical OR operator works the same as the AND operator, be it
that if an operand has a true value the other operand can be ignored.

\item
The \texttt{iif} function has three operands. Depending on the
condition, an element from the second or third operand has to be taken.
The resulting mask is formed by the mask of the condition and-ed
with the appropriate elements from the masks of the second and third operand.
\end{itemize}

It is possible that the entire mask of a subexpression is false.
If e.g. the mean of such a subexpression is taken, the result
is undefined. This is fully supported by LEL, because a scalar
value also has a mask associated with it.
One can see a masked-off scalar as a lattice with an all false mask.
Hence an operation involving an undefined scalar results in an
undefined scalar.
The following functions act as described below on fully masked-off
lattices:
\begin{itemize}
\item MEAN, VARIANCE, STDDEV, AVDEV, MIN, MAX
\\result in an undefined scalar:
\item NELEMENTS, NTRUE, NFALSE, SUM
\\result in a scalar with value 0.
\item ANY
\\results in a scalar with value F.
\item ALL
\\results in a scalar with value T.
\item LENGTH, NDIM
\\ignore the mask because only the shape of the lattice matters.
\end{itemize}


\section{Some further remarks}
\subsection{Optimization}
When giving a LEL expression, it is important to keep an eye
on performance issues.

LEL itself will do some optimization:
\begin{itemize}
\item As said in the introduction a LEL expression is evaluated
in chunks. However, a scalar subexpression is executed only once
when getting the first chunk.
E.g. in
  \begin{verbatim}
  lat1 + mean(lat2)
  \end{verbatim}
the subexpression \texttt{mean(lat2)} is executed only once
and not over and over again when the user gets chunks.

\item Often the exponent 2 is used in the \texttt{pow} function
(or operator \verb+^+). This is optimized by using multiplication
instead of using the system pow function.

\item When LEL finds a \htmlref{masked-off scalar}{LEL:MASKS}
in a subexpression, it does not evaluate the other operand.
Instead it sets the result immediately to a masked-off scalar.
Exceptions are the operators AND and OR and function \texttt{iif},
because their masks depend on the operand values.
\end{itemize}

The user can optimize by specifying the expression carefully.
\begin{itemize}
\item
It is strongly recommended to combine scalars into a subexpression to
avoid unnecessary scalar-lattice operations. E.g.
\begin{verbatim}
  2 * lat1 * pi()
\end{verbatim}
should be written as
\begin{verbatim}
  lat1 * (2 * pi())
or
  2 * pi() * lat1
\end{verbatim}
because in that way the scalars form a scalar subexpression
which is calculated only once. Note that the subexpression parentheses
are needed in the first case, because multiplications are done from
left to right.
\\In the future LEL will be optimized to shuffle the operands when
possible and needed.

\item
It is important to be careful with the automatic data type promotion
of single precision lattices. Several scalar functions (e.g. pi)
produce a double precision value, so using \texttt{pi} with a
single precision lattice causes the lattice to be promoted to double
precision. If accuracy allows it, it is much better to convert
\texttt{pi} to single precision.
E.g. assume \texttt{lat1} and \texttt{lat2} are single precision lattices.
\begin{verbatim}
  atan2(lat1,lat2) + pi()/2
\end{verbatim}
The result of \texttt{atan2} is single precision, because both
operands are single precision. However, \texttt{pi} is double
precision, so the result of \texttt{atan2} is promoted to double
precision to make the addition possible. Specifying the expression as:
\begin{verbatim}
  atan2(lat1,lat2) + float(pi())/2
\end{verbatim}
avoids that (expensive) data type promotion.

\item
\texttt{POW(LAT,2)} or \texttt{LAT}\verb+^+\texttt{2}
is faster than \texttt{LAT*LAT}, because it accesses lattice
\texttt{LAT} only once.

\item
\texttt{SQRT(LAT)} is faster than \texttt{LAT}\verb+^+\texttt{0.5}
or \texttt{POW(LAT,0.5)}

\item
\texttt{POW(U,2) + POW(V,2) $<$ 1000}\verb+^+\texttt{2} is considerably faster
than
\\\texttt{SQRT(SQUARE(U) + SQUARE(V)) $<$ 1000}, because it avoids the
\texttt{SQRT} function.

\item
LEL can be used with disk-based lattices and/or memory-based lattices.
When used with memory-based lattices it is better to make
subexpressions the first operand in another subexpression or a
function. E.g.
\\\texttt{lat1*lat2 + lat3}
\\is better than
\\\texttt{lat3 + lat1*lat2}
\\The reason is that in the first case no copy needs to be made of the
lattice data which already reside in memory. All LEL operators and
functions try to reference the data of their latter operands instead
of making a copy.
\\In general this optimization does not apply to LEL expression.
However, when using the true \htmlref{C++ interface}{LEL:GLISHC}
to classes like \texttt{LatticeExprNode}, one can easily use
memory-based lattices. In that case it can be advantageous to pay
attention to this optimization.

\end{itemize}


\section{\label{LEL:GLISHC}Interface to LEL}
There is a user and a programmer interface to LEL.
Glish functions form the user interface, while C++ functions
and classes form the programmer interface.
\begin{itemize}
\item
  The LEL interface in Glish is formed by the
  \htmlref{\texttt{calc}}{images:image.calc} and
  \htmlref{\texttt{expr}}{images:image.expr} functions in module
  \htmlref{\texttt{image}}{images:image} (in script \texttt{image.g}).
  The functions can be used
  to compose and/or execute a LEL expression.
  The \texttt{calc} constructor will evaluate the expression and store
  the result in an image with the given name.
  \\The \texttt{expr} constructor will only form the expression and
  treat it as a normal image thereafter.
  It is evaluated when actions (like \texttt{getchunk}) are done on it.
  \begin{verbatim}
    im := calc('outimage','inimage1+inimage2')
    im.statistics(...);
  \end{verbatim}
  The first command creates an image file \texttt{outimage} filling
  it with the sum of the input images. The second command does
  statistics on that new image.
  \\Writing it as
  \begin{verbatim}
    im := expr('inimage1+inimage2')
    im.statistics(...);
  \end{verbatim}
  would do the same with the exception of creating the output image.
  Instead the created image is transient; it only lives as an
  expression and each time it is used the expression is evaluated.

  Images created/opened in glish can be used with their glish name
  in a LEL expression. Similarly a region created in glish with the
  regionmanager can be used with its glish name.
  \\It is also possible to embed other glish variables and expressions in
  a LEL command using the syntax \texttt{\$variable} and
  \texttt{\$(expression)}. A variable can be a standard numeric scalar.
  An expression has to result in a numeric scalar.
  E.g. one can make a glish function like
  \begin{verbatim}
    img := image('inimage');
    return expr('min($img[$someregion], $clipvalue)');
  \end{verbatim}
  to return a transient image formed by a region in an image clipped at the
  given clipvalue.
  \\The substitution mechanism is described in more detail in the
  \htmlref{\texttt{substitute}}{misc:substitute}
  functions of module
  \htmlref{\texttt{misc}}{misc} of the
  \htmladdnormallink{User Reference
  Manual}{../../user/Refman/Refman.html}.
  \\The substitution mechanism uses the eval function in glish.
  As of 15-Jan-1999 eval only looks at global variables. This means
  that in a function one needs to create a global variable (with
  a unique name) if the variable is to be used in a LEL command.
  The global variable should be deleted at the end of the function.
  The name can be made unique by using the function name as a suffix.

  In glish applying a region to an image can also be done using the
  \htmlref{\texttt{subim}}{images:image.subimage} function in the image module.
  It forms an image from the given region in the input image.
  The constructed subimage can be used as a normal image in a LEL expression.
  E.g.
  \begin{verbatim}
    img := image('inimage');
    subimg := img.subimage(someregion, 'outname');
    return expr('min($subimg, $clipvalue)');
  \end{verbatim}
  has the same result. The only difference is that \texttt{subimage}
  creates another image on disk, which may not be desirable.

\item
  The C++ interface consists of 2 parts.
  \begin{enumerate}
  \item
    The function \texttt{command} in
    \htmladdnormallink{Images/ImageExprParse.h}
    {../../trial/implement/Images/ImageExprParse.html}
    can be used to execute a LEL command. The result is a
    \htmladdnormallink{LatticeExprNode}
    {../../trial/implement/Lattices/LatticeExprNode.html}
    object. E.g.
\begin{verbatim}
  LatticeExprNode seltab1 = ImageExprParse::command
         ("imagein1 + imagein2");
\end{verbatim}
    This example does the same as the Glish one shown above.

  \item
    The other interface is a true C++ interface having the
    advantage that C++ variables can be used. Class
    \htmladdnormallink{LatticeExprNode}
    {../../trial/implement/Lattices/LatticeExprNode.html}
    contains functions to form an expression. The same operators
    and functions as in the command interface are available.
    E.g.
\begin{verbatim}
  Float clipValue = 10;
  PagedImage<Float> image("imagein");
  LatticeExpr<Float> expr(min(image,clipValue));
\end{verbatim}
    forms an expression to clip the image. Note that the expression is
    written as a normal C++ expression. The overloaded operators and
    functions in class 
    \htmladdnormallink{LatticeExprNode}
    {../../trial/implement/Lattices/LatticeExprNode.html}
    ensure that the expression is formed in the correct way.
    \\Note that a \texttt{LatticeExprNode} object is usually
    automatically converted to a templated \texttt{LatticeExpr} object,
    which makes it possible to use it as a normal \texttt{Lattice}.
    \\So far the expression is only formed, but not evaluated.
    Evaluation is only done when the expression is used in an
    operation, e.g. as the source of the copy operation shown below.
\begin{verbatim}
  PagedImage<Float> imout("imageout");
  imout.copyData (expr);
\end{verbatim}

  \end{enumerate}
\end{itemize}

\section{Examples}
The following examples show some LEL commands.
\begin{description}
  \item[] \texttt{lat1+lat2}
    \\adds 2 lattices
  \item[] \texttt{mean(myimage:nomask)}
    \\results in a scalar value giving the mean of the image.
    No mask is used for the image, thus all pixels are used.
    The scalar value can be used as a lattice. E.g. it can be used as
    the source in an assignment to set all elements of another
    lattice to the mean.
  \item[] \texttt{complex(lat1,lat2)}
    \\results in a complex lattice formed by \texttt{lat1} as the
    real part and \texttt{lat2} as the imaginary part.
  \item[] \texttt{min(lat1, 2*mean(lat1))}
    \\results in a lattice where \texttt{lat1} is clipped at twice
    its mean value.
  \item[] \texttt{min(myimage, 2*mean(mymage[myregion]))}
    \\results in an image where \texttt{myimage} is clipped at twice
    the mean value of region \texttt{myregion} in the image..
  \item[] \texttt{lat1[lat1$>$2*min(lat1)]}
    \\results in a lattice with a mask. Only the pixels
    greater than twice the minimum are valid.
  \item[] \texttt{iif(lat1$<$mean(lat1),lat1*2,lat1/2)}
    \\results in a lattice where the elements less than the mean
    are doubled and the elements greater or equal to the mean are
    divided by 2.
\end{description}
Here follows a sample glish session showing some of the LEL
capabilities and how glish variables can be used in LEL.
\begin{verbatim}
duw01> glish
- include 'image.g'
- img:=image('tImageExpr2Gram_tmp.img')
- img.shape()
[10 10]
- img.getchunk()
[[1:10,]
   [0 10 20 30 40 50 60 70 80 90
    1 11 21 31 41 51 61 71 81 91
    2 12 22 32 42 52 62 72 82 92
    3 13 23 33 43 53 63 73 83 93
    4 14 24 34 44 54 64 74 84 94
    5 15 25 35 45 55 65 75 85 95
    6 16 26 36 46 56 66 76 86 96
    7 17 27 37 47 57 67 77 87 97
    8 18 28 38 48 58 68 78 88 98
    9 19 29 39 49 59 69 79 89 99] 
- reg:=drm.quarter();             # take inner quarter of image
- exprimg := expr('$img[$reg]')
- exprimg.getchunk()
[[1:5,]
   [33 43 53 63 73
    34 44 54 64 74
    35 45 55 65 75
    36 46 56 66 76
    37 47 57 67 77]
\end{verbatim}

\section{Future developments}
In the near or distant future LEL will be enhanced by adding new
features and by doing optimizations.
\begin{itemize}
  \item Handle slices like \texttt{image[1:10:2, 5:]}
        \\which defines the section directly in pixel coordinates (with
        stride 2 for the first axis).
  \item Do optimization by reordering the expression.
  \item Do optimization by recognizing common subexpressions.
\end{itemize}
