#!/bin/echo Usage: source
#-----------------------------------------------------------------------------
# UPinfo: help and general parameters for UP scripts
#-----------------------------------------------------------------------------
# Copyright (C) 2000
# Associated Universities, Inc. Washington DC, USA.
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation; either version 2 of the License, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 675 Massachusetts Ave, Cambridge, MA 02139, USA.
#
# Correspondence concerning AIPS++ should be addressed as follows:
#        Internet email: aips2-request@nrao.edu.
#        Postal address: AIPS++ Project Office
#                        National Radio Astronomy Observatory
#                        520 Edgemont Road
#                        Charlottesville, VA 22903-2475 USA
#
# $Id$
#
# The UPinfo script is called as 'source UPinfo' from any of the UP
# executable scripts to get general data. It is assumed that the name of the
# calling script is in the $script variable, and $usage contains the usage.
# If the -h switch is present, some help information is provided.
#
# Set the result
set ok = 0
# Set the non-switch arguments
set arg = ()
# Set the -c switch
set clr = 0
# Set the -d switch
set dbg = 0
# Set the -g switch
set gls = 0
# Set the -f switch
set fls = 0
# Set the -t switch
set upreal = 1
# Set the -l switch
set leav = 0
# Set the -i switch
set upinf = 0
# Set the -h switch
set hlp = 0
# Set the -n switch
set nox = 0
# Set the -r switch
set redef = 0
# Get switches and arguments
while ($# > 0)
      if ("$1" == "-c") then
	 set clr = 1
      else if ("$1" == "-d") then
	 set dbg = 1
	 set echo
      else if ("$1" == "-g") then
         set gls = 1
      else if ("$1" == "-f") then
         set fls = 1
      else if ("$1" == "-t") then
         set upreal = 0
      else if ("$1" == "-l") then
         set leav = 1
      else if ("$1" == "-i") then
         set upinf = 1
      else if ("$1" == "-h") then
         set hlp = 1
      else if ("$1" == "-n") then
         set nox = 1
      else if ("$1" == "-r") then
         set redef = 1
      else if ("$1" =~ -*) then
         echo "Unknown switch $1 present"
	 set hlp = 1
      else
         set arg = ($arg $1)
      endif
      shift
end
#
# Help
#
if ($hlp) then
  cat << '_EOF_'
The following UP scripts are available (-h gives this text):
    UPfind [-c] [-r] [-g] [-f] [-d] [-n] <typ>	    
	   find files according to egrep patterns in files .cc, .h and
	   templates, or generate it from a set of file patterns.
	   A list of files found is produced in <typ>.raw. Files in a set of
	   discard rules are removed. The result will be in <typ>.found.
	   -c	 start afresh for the given <typ>
	   -r	 only restart the general definitions for given <typ>
	   -g	 look in .g files rather than .cc, .h and templates
           -f    generate the list from a set of file patterns
	   -d    debug mode
           -n    will only generate the specific data, without executing
	   <typ> the code belonging to this set of usage (e.g. mx)
    UPlock [-c] [-r] [-d] [-n] <typ>
	   check if files found with UPfind are locked in the master. The
           resulting list will be in <typ>.locked
           -c  will clear all relevant information
	   -r  only restart the general definitions for given <typ>
           -d  will show some debug information
           -n  will only generate the specific data, without executing
    UPchange [-c] [-r] [-t] [-n] [-d] <typ>
 	   update all files (ao change ai) as given in <typ>.found created by
           UPfind.
           -c  will clear all relevant information
	   -r  only restart the general definitions for given <typ>
	   -t  will not execute for real, but only for test and display the
	       changes in <typ>.diff 
           -d  will show some debug information
           -n  will only generate the specific data, without executing
           <typ>.done and <typ>.error give lists of files successfully
           done or not.
    UPmove [-c] [-r] [-i] [-t] [-n] [-d] <typ>
	   Move specified files, and change references to them in system files.
	   The script uses UPfind and UPchange (see there for details)
           -c  will clear all relevant information
	   -r  only restart the general definitions for given <typ>
	   -i  will calculate all information, but no execution
           -t  will not execute for real, but only for test
           -d  will show some debug information
           -n  will only generate the specific data, without executing
           <typ>.done and <typ>.error give lists of files successfully
           done or not.
     UPtmpl [-c] [-r] [-d] [-n] <typ>
 	   get all files in the tmplinst directories. 
	   The file list will be in <typ>.tmpinst
           -c  will clear all relevant information
	   -r  only restart the general definitions for given <typ>
           -d  will show some debug information
           -n  will only generate the specific data, without executing
'_EOF_'
  exit 0
endif
#
# Get type
#
if ($#arg < 1) then
    echo "No <typ> given for ${script}"
    exit (1)
endif
set tp = $arg[1]
shift arg
#
# Check directories
#
unset ldir
unset dir
unset mdir
unset xao
unset xai
#
set ldir = `pwd`
if (! -w $ldir) then
    echo "Local directory ${ldir} not writeable "
    exit (1)
endif
#
# Get info
#
echo "Getting info..."
if ($clr) then
  if ("$script" == "UPfind") then 
    if (-e $ldir/${tp}.def) rm -f $ldir/${tp}.def
    if (-e $ldir/${tp}.up1) rm -f $ldir/${tp}.up1
    if (-e $ldir/${tp}.rm)  rm -f $ldir/${tp}.rm
  endif
  if ("$script" == "UPchange") then
    if (-e $ldir/${tp}.def) rm -f $ldir/${tp}.def
    if (-e $ldir/${tp}.sed) rm -f $ldir/${tp}.sed
    if (-e $ldir/${tp}.rcs) rm -f $ldir/${tp}.rcs
  endif 
  if ("$script" == "UPmove") then
    if (-e $ldir/${tp}.def) rm -f $ldir/${tp}.def
    if (-e $ldir/${tp}.up1) rm -f $ldir/${tp}.up1
    if (-e $ldir/${tp}.rm)  rm -f $ldir/${tp}.rm
    if (-e $ldir/${tp}.sel) rm -f $ldir/${tp}.sel
    if (-e $ldir/${tp}.cfnm) rm -f $ldir/${tp}.cfnm
    if (-e $ldir/${tp}.todo) rm -f $ldir/${tp}.todo
    if (-e $ldir/${tp}.sed) rm -f $ldir/${tp}.sed
  endif 
  if ("$script" == "UPtmpl" || "$script" == "UPlock") then
    if (-e $ldir/${tp}.def) rm -f $ldir/${tp}.def
  endif 
endif

if ($redef) then
  if (-e $ldir/${tp}.def) rm -f $ldir/${tp}.def
endif

if (-r $ldir/${tp}.def) then
   source $ldir/${tp}.def
endif

if (-r $ldir/${tp}.info) then
   source $ldir/${tp}.info
endif

if (! $?dir) then
   set dir = ($AIPSPATH)
   set dir = $dir[1]
   echo "Make sure you have a proper mktree built before proceeding..."
   echo -n "Assuming master search tree in $dir/code. ok? (y|n) [n]: "
   set repl=($<)
   if ($repl != 'y') then
      echo "Restart with proper AIPSROOT set (use aipsinit)"
      exit (1)
   endif
endif 

if (! $?mdir) then
   set x = "~/aips++"
   while (! -d $x/code) 
      echo "Path to local aips++ tree root is not $x"
      echo -n "Specify your local aips++ tree root: "
      set x = "$<"
   end
   set mdir = "$x"
   unset x
endif

if (! $?xao || ! $?xai) then
   set xao = rao
   set xai = rai
   echo -n "Assuming use of rao/rai, rather than ao/ai. ok? (y|n) [y]: "
   set repl=($<)
   if ($repl == 'n' || $repl == 'N') then
      set xao = ao
      set xai = ai
   endif
endif

if ("$script" == "UPmove") then
    set domv = 0
    echo -n "Need to move files first to new directory (y|n) [n]? "
    set repl=($<)
    if ($repl == 'y') then
	echo "Note: The moving can only be done while logged into aoc, since "
	echo "      it uses the amv command."
	echo -n "Do you want to continue (y|n) [n]? "
	set repl=($<)
	if ($repl == 'y') then
	    set domv = 1
	endif
    endif
endif

if (! -e $ldir/${tp}.def) then
   echo "set dir = $dir" >! $ldir/${tp}.def
   echo "set mdir = $mdir" >> $ldir/${tp}.def
   echo "set xao = $xao" >> $ldir/${tp}.def
   echo "set xai = $xai" >> $ldir/${tp}.def
endif 
#
# Correct result
#
set ok = 1
exit 0
#



